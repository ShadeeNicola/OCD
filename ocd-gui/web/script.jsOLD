const folderInput = document.getElementById('folder-path');
const browseBtn = document.getElementById('browse-btn');
const deployBtn = document.getElementById('deploy-btn');
const statusMessage = document.getElementById('status-message');
const manualInputNote = document.getElementById('manual-input-note');
const historyDropdown = document.getElementById('history-dropdown');
const deploymentSection = document.getElementById('deployment-section');
const progressOverview = document.getElementById('progress-overview');
const outputWindow = document.getElementById('output-window');
const outputContent = document.getElementById('output-content');
const toggleOutputBtn = document.getElementById('toggle-output-btn');
const saveOutputBtn = document.getElementById('save-output-btn');
const progressBarSection = document.getElementById('progress-bar-section');
const progressBarFill = document.getElementById('progress-bar-fill');
const progressText = document.getElementById('progress-text');
const progressPercentage = document.getElementById('progress-percentage');

const HISTORY_KEY = 'ocd-folder-history';
const MAX_HISTORY_ITEMS = 10;

let currentDeploymentOutput = '';
let currentProgressItems = new Map();
let websocket = null;
let lastDeploymentStatus = null;
let stageStatus = {
    prerequisites: 'pending',
    settings: 'pending',
    build: 'pending',
    deploy: 'pending',
    patch: 'pending'
};

function cleanAnsiEscapes(text) {
    // Remove ANSI escape sequences
    return text.replace(/\x1b\[[0-9;]*m/g, '');
}

function showStatus(message, type, persistent = false) {
    statusMessage.textContent = message;
    statusMessage.className = `status-message status-${type}`;
    statusMessage.style.display = 'block';

    if (!persistent) {
        setTimeout(() => {
            statusMessage.style.display = 'none';
        }, 5000);
    }
}

function validateFolderPath() {
    const path = folderInput.value.trim();
    deployBtn.disabled = !path;
}

function normalizePath(path) {
    return path.replace(/\\/g, '/');
}

function getHistory() {
    try {
        const history = localStorage.getItem(HISTORY_KEY);
        return history ? JSON.parse(history) : [];
    } catch (e) {
        return [];
    }
}

function saveHistory(history) {
    try {
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    } catch (e) {
        console.warn('Could not save history to localStorage');
    }
}

function addToHistory(path) {
    const normalizedPath = normalizePath(path);
    let history = getHistory();

    history = history.filter(item => normalizePath(item) !== normalizedPath);
    history.unshift(path);

    if (history.length > MAX_HISTORY_ITEMS) {
        history = history.slice(0, MAX_HISTORY_ITEMS);
    }

    saveHistory(history);
}

function removeFromHistory(path) {
    const normalizedPath = normalizePath(path);
    let history = getHistory();
    history = history.filter(item => normalizePath(item) !== normalizedPath);
    saveHistory(history);
    showHistoryDropdown();
}

function showHistoryDropdown() {
    const history = getHistory();
    historyDropdown.innerHTML = '';

    if (history.length === 0) {
        const emptyDiv = document.createElement('div');
        emptyDiv.className = 'history-empty';
        emptyDiv.textContent = 'No recent folders';
        historyDropdown.appendChild(emptyDiv);
    } else {
        history.forEach(path => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'history-item';

            const pathSpan = document.createElement('span');
            pathSpan.className = 'history-path';
            pathSpan.textContent = path;
            pathSpan.title = path;

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'history-delete';
            deleteBtn.textContent = '√ó';
            deleteBtn.title = 'Remove from history';

            pathSpan.addEventListener('click', (e) => {
                e.stopPropagation();
                folderInput.value = path;
                validateFolderPath();
                hideHistoryDropdown();
            });

            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeFromHistory(path);
            });

            itemDiv.appendChild(pathSpan);
            itemDiv.appendChild(deleteBtn);
            historyDropdown.appendChild(itemDiv);
        });
    }

    historyDropdown.style.display = 'block';
}

function hideHistoryDropdown() {
    historyDropdown.style.display = 'none';
}

function initializeProgressOverview() {
    progressOverview.innerHTML = '';
    currentProgressItems.clear();

    // Reset stage status
    stageStatus = {
        prerequisites: 'pending',
        settings: 'pending',
        build: 'pending',
        deploy: 'pending',
        patch: 'pending'
    };

    // Add initial progress items
    const stages = [
        { id: 'prerequisites', label: 'Connection Checks & Prerequisites', status: 'pending' },
        { id: 'settings', label: 'Maven Settings XML Update', status: 'pending' },
        { id: 'build', label: 'Building Microservices', status: 'pending' },
        { id: 'deploy', label: 'Docker Image Creation', status: 'pending' },
        { id: 'patch', label: 'Kubernetes Deployment', status: 'pending' }
    ];

    stages.forEach(stage => {
        addProgressItem(stage.id, stage.label, stage.status);
    });
}

function addProgressItem(id, label, status, details = '') {
    let item = currentProgressItems.get(id);

    if (!item) {
        item = document.createElement('div');
        item.className = 'progress-item';
        item.innerHTML = `
            <div class="progress-status status-${status}"></div>
            <div class="progress-label">${label}</div>
            <div class="progress-details">${details}</div>
        `;
        progressOverview.appendChild(item);
        currentProgressItems.set(id, item);
    } else {
        updateProgressItem(id, label, status, details);
    }
}

function updateProgressItem(id, label, status, details = '') {
    const item = currentProgressItems.get(id);
    if (!item) return;

    const statusDiv = item.querySelector('.progress-status');
    const labelDiv = item.querySelector('.progress-label');
    const detailsDiv = item.querySelector('.progress-details');

    statusDiv.className = `progress-status status-${status}`;
    labelDiv.textContent = label;
    detailsDiv.textContent = details;
    // Add debug logging
    console.log(`Updated progress item ${id}:`, {
        label: label,
        status: status,
        details: details,
        detailsDiv: detailsDiv,
        detailsDivContent: detailsDiv.textContent
    });

}

function addServiceProgressItem(service, stage, status, details = '') {
    const cleanService = cleanAnsiEscapes(service);
    const id = `${cleanService}-${stage}`;
    const label = `${cleanService} - ${stage.charAt(0).toUpperCase() + stage.slice(1)}`;
    addProgressItem(id, label, status, details);
}

function updateStageProgress(stage, status) {
    if (stageStatus[stage] !== status) {
        stageStatus[stage] = status;

        // Update the main stage item
        const stageLabels = {
            prerequisites: 'Connection Checks & Prerequisites',
            settings: 'Maven Settings XML Update',
            build: 'Building Microservices',
            deploy: 'Docker Image Creation',
            patch: 'Kubernetes Deployment'
        };

        if (stageLabels[stage]) {
            // Get existing details before updating
            const existingItem = currentProgressItems.get(stage);
            const existingDetails = existingItem ? existingItem.querySelector('.progress-details').textContent : '';

            // For prerequisites and settings stages, always preserve details
            // For other stages, clear details when completed or failed
            let detailsToShow = '';
            if (stage === 'prerequisites' || stage === 'settings') {
                detailsToShow = existingDetails; // Always preserve prerequisites and settings details
            } else if (status === 'running') {
                detailsToShow = existingDetails; // Show details while running
            } else if (status === 'error') {
                detailsToShow = existingDetails; // Preserve details when failed
            }
            // For other stages when completed (status === 'success'), detailsToShow remains empty

            updateProgressItem(stage, stageLabels[stage], status, detailsToShow);
        }
    }
}

function updateProgressBar(percentage, text) {
    progressBarFill.style.width = percentage + '%';
    progressText.textContent = text;
    progressPercentage.textContent = percentage + '%';
}


function appendOutput(content, type = 'normal') {
    const cleanContent = cleanAnsiEscapes(content);
    const line = document.createElement('div');
    line.className = `output-line ${type}`;
    line.textContent = cleanContent;
    outputContent.appendChild(line);
    outputContent.scrollTop = outputContent.scrollHeight;

    currentDeploymentOutput += cleanContent + '\n';
    saveOutputBtn.disabled = false;
}

function clearOutput() {
    outputContent.innerHTML = '';
    currentDeploymentOutput = '';
    saveOutputBtn.disabled = true;
}

function saveOutput() {
    if (!currentDeploymentOutput) return;

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `ocd-deployment-${timestamp}.txt`;

    const blob = new Blob([currentDeploymentOutput], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
}

function handleProgressUpdate(data) {
    console.log('Progress update received:', data); // Add this debug line

    if (data.stage && data.status) {
        if (data.service) {
            const cleanService = cleanAnsiEscapes(data.service);
            addServiceProgressItem(cleanService, data.stage, data.status, data.details);

            if (data.status === 'running') {
                updateStageProgress(data.stage, 'running');
                // Update progress bar based on stage
                if (data.stage === 'settings') updateProgressBar(20, 'Updating Maven settings...');
                else if (data.stage === 'build') updateProgressBar(40, 'Building microservices...');
                else if (data.stage === 'deploy') updateProgressBar(70, 'Creating Docker images...');
                else if (data.stage === 'patch') updateProgressBar(90, 'Deploying to Kubernetes...');
            } else if (data.status === 'success') {
                updateStageProgress(data.stage, 'success');
            } else if (data.status === 'error') {
                console.log('Service error detected, updating stage to error:', data.stage); // Debug line
                updateStageProgress(data.stage, 'error');
            }
        } else {
            console.log('Updating main stage:', data.stage, data.message, data.status, data.details);
            updateProgressItem(data.stage, data.message, data.status, data.details);
            updateStageProgress(data.stage, data.status);

            // Update progress bar for main stage completions
            if (data.status === 'success') {
                if (data.stage === 'prerequisites') updateProgressBar(5, 'Prerequisites completed');
                else if (data.stage === 'settings') updateProgressBar(10, 'Maven settings updated');
                else if (data.stage === 'build') updateProgressBar(50, 'Build completed');
                else if (data.stage === 'deploy') updateProgressBar(80, 'Docker images created');
                else if (data.stage === 'patch') updateProgressBar(100, 'Deployment completed');
            } else if (data.status === 'running') {
                updateStageProgress(data.stage, 'running');
                if (data.stage === 'prerequisites') updateProgressBar(2, 'Checking prerequisites...');
                else if (data.stage === 'settings') updateProgressBar(7, 'Updating Maven settings...');
                else if (data.stage === 'build') updateProgressBar(30, 'Building microservices...');
                else if (data.stage === 'deploy') updateProgressBar(60, 'Creating Docker images...');
                else if (data.stage === 'patch') updateProgressBar(85, 'Deploying to Kubernetes...');
            } else if (data.status === 'error') {
                console.log('Main stage error detected:', data.stage);
                // Handle error status for progress bar
                updateProgressBar(0, `${data.stage} failed`);
            }
        }
    }
}

function startWebSocketDeployment(folderPath) {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/deploy`;

    websocket = new WebSocket(wsUrl);

    websocket.onopen = function() {
        websocket.send(JSON.stringify({ folderPath: folderPath }));

        deploymentSection.style.display = 'block';
        initializeProgressOverview();
        clearOutput();

        progressBarSection.style.display = 'block';
        progressBarFill.style.width = '0%';
        progressText.textContent = 'Initializing deployment...';
        progressPercentage.textContent = '0%';
    };

    websocket.onmessage = function(event) {
        const data = JSON.parse(event.data);

        switch (data.type) {
            case 'output':
                appendOutput(data.content);
                break;

            case 'progress':
                handleProgressUpdate(data);
                break;

            case 'complete':
                lastDeploymentStatus = data.success ? 'success' : 'error';
                const message = data.success ?
                    'Deployment completed successfully!' :
                    `Deployment failed: ${data.content}`;

                if (data.success) {
                    updateProgressBar(100, 'Deployment completed successfully!');
                    addToHistory(folderPath);
                    updateStageProgress('patch', 'success');
                } else {
                    updateProgressBar(0, 'Deployment failed');
                    // Don't automatically mark patch as error - the actual failed stage should already be marked
                    // The backend should send the correct stage that failed
                }

                showStatus(message, lastDeploymentStatus, true);
                deployBtn.disabled = false;
                deployBtn.textContent = 'Deploy Changes';
                websocket = null;
                break;
        }
    };

    websocket.onerror = function(error) {
        console.error('WebSocket error:', error);
        showStatus('WebSocket connection error', 'error', true);
        deployBtn.disabled = false;
        deployBtn.textContent = 'Deploy Changes';
        websocket = null;
    };

    websocket.onclose = function() {
        if (deployBtn.textContent === 'Deploying...') {
            deployBtn.disabled = false;
            deployBtn.textContent = 'Deploy Changes';
        }
        websocket = null;
    };
}

// Event Listeners
folderInput.addEventListener('click', (e) => {
    e.stopPropagation();

    // Show smart suggestions if no value is entered
    if (!folderInput.value.trim()) {
        showSmartFolderSuggestions();
    } else {
        showHistoryDropdown();
    }
});


document.addEventListener('click', (e) => {
    if (!folderInput.contains(e.target) && !historyDropdown.contains(e.target)) {
        hideHistoryDropdown();
    }
});

folderInput.addEventListener('input', validateFolderPath);
folderInput.addEventListener('paste', () => {
    setTimeout(validateFolderPath, 10);
});

browseBtn.addEventListener('click', async function() {
    browseBtn.disabled = true;
    browseBtn.textContent = 'Browsing...';

    try {
        const response = await fetch('/api/browse');
        const data = await response.json();

        if (data.success) {
            folderInput.value = data.folderPath;
            folderInput.readOnly = false;
            validateFolderPath();
            addToHistory(data.folderPath);
            hideHistoryDropdown();
            showStatus('Folder selected successfully', 'success');
        } else {
            if (data.folderPath) {
                folderInput.value = data.folderPath;
                folderInput.readOnly = false;
                manualInputNote.style.display = 'block';
                validateFolderPath();
                showStatus(data.message + ' Please verify or edit the path above.', 'warning');
            } else {
                folderInput.readOnly = false;
                manualInputNote.style.display = 'block';
                showStatus(data.message, 'error');
            }
        }
    } catch (error) {
        folderInput.readOnly = false;
        manualInputNote.style.display = 'block';
        showStatus('Error opening folder dialog: ' + error.message, 'error');
    } finally {
        browseBtn.disabled = false;
        browseBtn.textContent = 'Browse';
    }
});

deployBtn.addEventListener('click', async function() {
    if (!folderInput.value.trim()) {
        showStatus('Please select a project folder first', 'error');
        return;
    }

    // Clear previous deployment status when starting new deployment
    lastDeploymentStatus = null;
    statusMessage.style.display = 'none';

    deployBtn.disabled = true;
    deployBtn.textContent = 'Deploying...';

    const folderPath = folderInput.value.trim();
    startWebSocketDeployment(folderPath);
});

toggleOutputBtn.addEventListener('click', function() {
    const isVisible = outputWindow.style.display !== 'none';

    if (isVisible) {
        outputWindow.style.display = 'none';
        toggleOutputBtn.textContent = 'Show Output';
    } else {
        outputWindow.style.display = 'block';
        toggleOutputBtn.textContent = 'Hide Output';
    }
});

saveOutputBtn.addEventListener('click', saveOutput);

// Initialize
folderInput.readOnly = false;
validateFolderPath();

// Restore last deployment status on page load
window.addEventListener('load', function() {
    if (lastDeploymentStatus) {
        const message = lastDeploymentStatus === 'success' ?
            'Last deployment completed successfully!' :
            'Last deployment failed';
        showStatus(message, lastDeploymentStatus, true);
    }
});

function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

    document.documentElement.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);

    const themeToggle = document.querySelector('.theme-toggle');
    themeToggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è Light' : 'üåô Dark';
}

function addDeveloperCredit() {
    const footer = document.createElement('div');
    footer.className = 'developer-credit';
    footer.innerHTML = `
        <span>Developed by Shadee Nicola</span>
        <span>V1.0</span>
        <button class="mail-btn" onclick="sendMail()" title="Contact Developer">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
            </svg>
        </button>
    `;
    document.body.appendChild(footer);
}

function sendMail() {
    const subject = encodeURIComponent('OCD Tool - Contact');
    const body = encodeURIComponent('Hello Shadee,\n\nI am contacting you regarding the OCD (One Click Deployer) tool.\n\n');
    window.open(`mailto:shadee.nicola@amdocs.com?subject=${subject}&body=${body}`);
}

addDeveloperCredit();